# поиск гласных букв

`
def count_vowels(text):
    vowels = "aeiouAEIOUаеёиоуыэюяАЕЁИОУЫЭЮЯ"
    count = 0
    for char in text:
        if char in vowels:
            count += 1
    return count


if __name__ == "__main__":
    user_input = input("Введите предложение: ")
    vowel_count = count_vowels(user_input)
    print("Количество гласных букв в предложении:", vowel_count)
`
пояснение кода:
count_vowels(text) функция:
Принимает строку text в качестве аргумента.
Определяет строку vowels, содержащую все гласные буквы (как строчные, так и прописные) на английском и русском языках.
Инициализирует переменную count нулем, чтобы хранить количество гласных.
Итерируется по каждому символу char в строке text.
Проверяет, содержится ли char в строке vowels. Если да, то это гласная буква, и count увеличивается на 1.
Возвращает общее количество гласных count.

if __name__ == "__main__": блок:
Этот блок кода выполняется только тогда, когда скрипт запускается напрямую (а не импортируется как модуль).
input("Введите предложение: ") запрашивает у пользователя ввод предложения и сохраняет его в переменной user_input.
count_vowels(user_input) вызывает функцию count_vowels для подсчета гласных в введенном предложении. Результат сохраняется в переменной vowel_count.
print("Количество гласных букв в предложении:", vowel_count) выводит результат на экран.

# повторы

`
def find_duplicates(arr):
    duplicates = []
    seen = set()

    for element in arr:
        if element in seen:
            if element not in duplicates:
                duplicates.append(element)
        else:
            seen.add(element)

    return duplicates


if __name__ == "__main__":
    my_array = [1, 2, 3, 4, 2, 5, 6, 3, 7, 8, 1]
    duplicate_elements = find_duplicates(my_array)

    if duplicate_elements:
        print("Повторяющиеся элементы:", duplicate_elements)
    else:
        print("В массиве нет повторяющихся элементов.")
`

пояснение:

find_duplicates(arr) функция:
Принимает массив (список) arr в качестве аргумента.
Создает пустой список duplicates для хранения повторяющихся элементов.
Создает пустое множество seen. Множества обеспечивают очень быстрый поиск элементов (в среднем O(1)), что делает этот алгоритм более эффективным, чем использование списка для отслеживания уже встреченных элементов.
Итерируется по каждому element в массиве arr.

if element in seen:: Проверяет, встречался ли элемент element ранее (есть ли он в множестве seen).
Если да, значит, это дубликат. Добавляем его в список duplicates (если он там еще не присутствует - это нужно чтобы избежать повторного добавления одного и того же дубликата, если он в массиве несколько раз).
else:: Если элемент element еще не встречался:
seen.add(element): Добавляем элемент element в множество seen, чтобы отметить его как встреченный.
Возвращает список duplicates, содержащий все найденные повторяющиеся элементы.

if __name__ == "__main__": блок
Создает пример массива my_array.
Вызывает функцию find_duplicates для поиска дубликатов в my_array. Результат сохраняется в duplicate_elements.
Проверяет, содержит ли duplicate_elements какие-либо элементы.
Если да, то выводит сообщение, содержащее список повторяющихся элементов.
Если нет, то выводит сообщение о том, что в массиве нет повторяющихся элементов.

Множество seen
Использование множества seen для отслеживания встреченных элементов значительно повышает эффективность алгоритма. Проверка наличия элемента во множестве (операция element in seen) выполняется в среднем за O(1) времени. Если бы мы использовали список вместо множества, то проверка наличия элемента (например, if element in seen_list:) заняла бы в среднем O(n) времени, где n - количество элементов в списке seen_list. Это сделало бы алгоритм в целом менее эффективным, особенно для больших массивов. Таким образом, использование множества позволяет алгоритму find_duplicates работать быстрее и эффективнее.
